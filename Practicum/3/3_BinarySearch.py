'''
На каждом шаге сужается диапазон поиска. Правая граница сдвигается влево, либо
левая — вправо. При реализации обязательно нужно удостовериться, что границы
действительно уменьшаются при любом наборе параметров, иначе рекурсия может
уйти в бесконечный цикл:
в нашем случае всегда mid < right, поэтому [left, mid) меньше по длине, чем
[left, right);
кроме того, left < mid + 1 (хотя mid может оказаться равным left), поэтому
[mid + 1, right) меньше по длине, чем [left, right).
В какой-то момент левая граница может стать равной правой, такой полуоткрытый
интервал не содержит элементов. Можно сделать вывод, что искомого элемента в
массиве нет и вернуть –1. Это будет базовым случаем рекурсии.
Второй базовый случай реализуется, если элемент на позиции mid оказался
искомым. Этот случай мы обсудили ранее.
'''


def binary_search(arr, x, left, right):
    if right <= left:  # промежуток пуст
        return -1
    # промежуток не пуст
    mid = (left + right) // 2
    if arr[mid] == x:  # центральный элемент — искомый
        return mid
    elif x < arr[mid]:  # искомый элемент меньше центрального
        # значит следует искать в левой половине
        return binary_search(arr, x, left, mid)
    else:  # иначе следует искать в правой половине
        return binary_search(arr, x, mid + 1, right)


'''
# изначально мы запускаем двоичный поиск на всей длине массива
index = binarySearch(arr, x, left = 0, right = len(arr))
Отлично, наша функция готова!
А если массив отсортирован по убыванию?
Этот алгоритм можно легко модифицировать для поиска в массиве, отсортированном
по убыванию. В этом случае, если центральный элемент меньше искомого, нужно
продолжать поиск в левой части. А если больше — в правой.
'''


def binary_search_descending(arr, x, left, right):
    if right <= left:
        return -1
    mid = (left + right) // 2
    if arr[mid] == x:
        return mid
    elif arr[mid] < x:  # искомый элемент больше центрального
        # на этот раз все элементы больше центрального
        # располагаются в левой половине
        return binary_search_descending(arr, x, left, mid)
    else:
        return binary_search_descending(arr, x, mid + 1, right)

'''
Генерация последовательностей из 0 и 1
Рассмотрим пример генерации всех возможных последовательностей длины n из
нулей и единиц.
Функция принимает в качестве параметра число n и строку prefix. Вызываем
функцию с параметром n и значением prefix, равным пустой строке. Далее будем
добавлять в эту строку 0 и 1. В каждом рекурсивном вызове n означает, сколько
ещё символов нужно добавить в строку. Рекурсия останавливается, когда n = 0,
то есть символы добавлять больше не требуется. Это базовый случай рекурсии.
В рекурсивном случае функция вызывает себя дважды, но с разными параметрами.
В первый раз она добавляет в строку prefix цифру 0, а во второй раз — 1. При
этом значение n каждый раз уменьшается на 1, а prefix удлиняется на один
символ. Таким образом, рекурсия уходит на n уровней в глубину.
Теперь запишем это так:
'''


def gen_binary(n, prefix):
    if n == 0:
        print(prefix)
    else:
        gen_binary(n - 1, prefix + '0')
        gen_binary(n - 1, prefix + '1')


gen_binary(3, '')

'''
Если пройти от корня по всем веткам, получим все возможные последовательности
из 0 и 1 длины 3.
Вычисление количества последовательностей
Кстати, всего таких последовательностей 2^n2
n
 .
Разберёмся, почему. У нас есть nn позиций. На каждой из них может стоять
0 или 1, то есть возможны 2 варианта. Последовательностей длины один — 2,
длины два — в 2 раза больше, длины три — ещё в 2 раза больше. Итого получим
произведение nn двоек.
Если посчитать количество путей в нашем дереве от корня до листа, получится
действительно 2^3=82
3
 =8.
Рекурсия часто используется для перебора вариантов. Например, у нас есть n
различных предметов. Каждый из предметов может быть взят или отложен в сторону.
Тогда есть 2^n2
n вариантов того, как взять набор предметов. Пронумеруем предметы числами от 1
до nn. Каждый предмет может быть взят (обозначим цифрой 1) или отложен в
сторону (обозначим как 0). Так мы фактически свели задачу перебора вариантов
к задаче генерации последовательностей из нулей и единиц.
'''
